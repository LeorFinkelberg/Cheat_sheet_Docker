\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Практика использования и \\наиболее полезные конструкции \texttt{Docker}}

\author{\itshape Подвойский А.О.}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Общие сведения о системе Docker}

\subsection{Установка}

Установить \texttt{Docker} можно с помощью менеджера пакетов \texttt{conda}

\begin{lstlisting}[
style = ironpython,
numbers = none
]
conda install -c conda-forge docker-py
\end{lstlisting}

На текущий момент без серьезных проблем \texttt{Docker} работает только на 64-битовом \texttt{Linux}.

Для нормальной работы на \texttt{MacOS X} или \texttt{Windows} потребуется дополнительно установить какую-либо виртуальную машину в полной комплектации или пакет \texttt{Docker Toolbox}:

\begin{itemize}
	\item для \texttt{MacOS X}: \url{https://docs.docker.com/toolbox/toolbox_install_mac/},
	
	\item для \texttt{Windows}\footnote{Поддерживается даже \texttt{Windows 7}}: \url{https://docs.docker.com/toolbox/toolbox_install_windows/}; после установки \texttt{Docker Toolbox} останется только запустить \texttt{Docker Quick Start Terminal}.
\end{itemize}

\subsection{Анализ manifest-файлов Docker}

Чтобы извлечь данные с удаленного репозитория нужно воспользоваться конструкцией
\begin{lstlisting}[
style = bash,
numbers = none
]
docker pull leorfinkelberg/app_name:tag_name
\end{lstlisting}
или что то же самое (по умолчанию, если хост не указан, используется DockerHub)
\begin{lstlisting}[
style = bash,
numbers = none
]
$ docker pull registry.hub.docker.com/leorfinkelberg/app_name:tag_name
\end{lstlisting}

Пытаемся скачать manifest-файл
\begin{lstlisting}[
style = bash,
numbers = none
]
$ curl -D - -s https://registry.hub.docker.com/v2/leorfinkelberg/manifests/latest
# вернет
HTTP/1.1 401 Unauthorized
Content-Type: application/json
Docker-Distribution-Api-Version: registry/2.0
Www-Authenticate: Bearer realm="https://auth.docker.io/token",service="registry.docker.io",scope="repository:leorfinkelberg/myapp:pull"
Date: Thu, 04 Jun 2020 17:57:01 GMT
Content-Length: 163
Strict-Transport-Security: max-age=31536000

{"errors":[{"code":"UNAUTHORIZED","message":"authentication required","detail":[{"Type":"repository","Class":"","Name":"leorfinkelberg/myapp","Action":"pull"}]}]}
\end{lstlisting}

Здесь флаг \verb|-D| сохраняет заголовки, возвращенные сервером, \verb|-s| заставляет выводить минимум информации.

Возникли сложности с авторизацией. Смотрим на строку \texttt{Www-Authenticate} и на основании информации, приведенной в этой строке, строим запрос
\begin{lstlisting}[
style = bash,
numbers = none
]
$ curl -D - -s 'https://auth.docker.io/token?service=registry.docker.io&scope=repository:leorfinkelberg/myapp:pull'
# вернет
HTTP/1.1 200 OK
Content-Type: application/json
Date: Thu, 04 Jun 2020 13:46:22 GMT
Transfer-Encoding: chunked
Strict-Transport-Security: max-age=31536000

{"token":"eyJhbGciOiJSUzI1NiIsInR5cCI6...}
\end{lstlisting}

Параметр \verb|scope| описывает запрашиваемые права. Затем создаем переменную окружения \texttt{REGISTRY\_TOKEN}
\begin{lstlisting}[
style = bash,
numbers = none
]
export REGISTRY_TOKEN="eyJhbGciOiJSUzI1NiIsInR5..."
\end{lstlisting}

А затем конструируем такой запрос и получаем manifest-файл в формате json
\begin{lstlisting}[
style = bash,
numbers = none
]
$ curl -D - -s -H "Authorization: Bearer $REGISTRY_TOKEN" https://registry.hub.docker.com/v2/leorfinkelberg/myapp/manifests/latest
# вернет
HTTP/1.1 200 OK
Content-Length: 5778
Content-Type: application/vnd.docker.distribution.manifest.v1+prettyjws
Docker-Content-Digest: sha256:cb0c53e4c8471a2deb8d22df00646ee2abe81cb11818ed12d0fe4e697ccec93f
Docker-Distribution-Api-Version: registry/2.0
Etag: "sha256:cb0c53e4c8471a2deb8d22df00646ee2abe81cb11818ed12d0fe4e697ccec93f"
Date: Thu, 04 Jun 2020 18:11:59 GMT
Strict-Transport-Security: max-age=31536000

{
    "schemaVersion": 1,
    "name": "leorfinkelberg/myapp",
    "tag": "latest",
    "architecture": "amd64",
    "fsLayers": [
        {
            "blobSum": "sha256:bd1a014b71c4b5b06a7f57486a8be2d690fc6034ede049ab63e9e827c9814e5a"
        },
...
    "signatures": [
        {
            "header": {
               "jwk": {
                   "crv": "P-256",
                   "kid": "PDNB:TMYN:5AZL:Y3UQ:6ACR:VJER:ON6K:H5XV:AIUX:7ZBZ:2PUD:GUI4",
                   "kty": "EC",
                   "x": "o_2HgAeBYjFsEhtDbFsB0afzrwkODIgIsDg7Tslk33o",
                   "y": "04Wp7S22uBJYbca2CABSBIl8ZkJUksit8dLQDvshhro"
               },
               "alg": "ES256
            },
            "signature": "eWlDslYAVkLGltlSfB9-Pboa3aWIuKEkaMomNx07xH...",
            "protected": "eyJmb3JtYXRMZW5ndGgiOjUxMzEsImZvcm1hdFRhaWwiOi..."
        }
    ]
}
\end{lstlisting}

Сохраняем manifest-файл
\begin{lstlisting}[
style = bash,
numbers = none
]
curl -o manifest.json -s -H "Authorization: Bearer $REGISTRY_TOKEN" https://registry.hub.docker.com/v2/leorfinkelberg/myapp/manifests/latest
\end{lstlisting}

Контрольные суммы слоев образа можно посмотреть так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ $ docker inspect --format {{.RootFS.Layers}} leorfinkelberg/myapp
\end{lstlisting}


\subsection{Контейнеры}

\emph{Контейнеры} представляют собой средства инкапсуляции приложения вместе со всеми его зависимостями.

Поскольку \texttt{Docker} сам по себе не обеспечивает реализацию любого типа виртуализации, контейнеры всегда должны соответствовать ядру хоста -- контейнер на \texttt{Windows Server} может работать только на хосте под управлением операционной системы \texttt{Windows Server}, а 64-битный \texttt{Linux}-контейнер работает только на хосте с установленной 64-битной версией операционной системы \texttt{Linux} \cite{mouat:docker-2017}.

\subsection{Создание образов из Dockerfile}

\texttt{Dockerfile} -- это обычный текстовый файл, содержащий набор операций, которые могут быть использованы для создания Docker-образа.

Пример. Для начала создадим новый каталог и собственно Dockerfile

\begin{lstlisting}[
numbers = none
]
$ mkdir cowsay
$ cd cowsay
$ touch Dockerfile
\end{lstlisting}

Затем в созданный \texttt{Dockerfile} добавим следующее 
\begin{lstlisting}[
title = {\sffamily Dockerfile},
numbers = none
]
FROM debian:wheezy
MAINTAINER John Smith <john@smith.com>
RUN apt-get update && apt-get install -y cowsay fortune
COPY entrypoint.sh /
ENTRYPOINT ["/entrypoint.sh"]
\end{lstlisting}

Инструкция \texttt{FROM} определяет базовый образ ОС (это в данном случае \texttt{debian} с уточненной версией <<wheezy>>). Инструкция \texttt{FROM} является строго обязательной для всех файлов Dockerfile как самая первая незакомментированная инструкция.

Инструкция \texttt{MAINTAINER} просто определяет информацию, позволяющую связаться с автором образа.

Инструкция \texttt{COPY} копирует файл из файловой системы хоста в файловую систему образа, где первый аргумент определяет файл хост, а второй -- целевой путь.

Инструкция \texttt{RUN} определяет команды, выполняемые в командной оболочке внутри данного образа.

Комментарии к скрипту \texttt{entrypoint.sh}. Файл \texttt{entrypoint.sh} должен лежать в той же директории, что и файл \texttt{Dockerfile} и иметь содержание на подобие следующего
\begin{lstlisting}[
title = {\sffamily entrypoint.sh},
numbers = none
]
if [ $# -eq 0 ]; then
    /usr/games/fortune | /usr/games/cowsay
else
    /usr/games/cowsay "$@"
fi
\end{lstlisting}

Здесь конструкция \texttt{[...]} -- это форма\footnote{Есть еще вариант \texttt{test выражение}, но форма \texttt{[ выражение ]} более популярна} команды \texttt{test} для проверки различных условий. Последовательность символов \texttt{\$\#} -- встроенная переменная, обозначающая количество аргументов в командной строке. Последовательность символов \texttt{\$@} -- это все аргументы командной строки, а \texttt{"\$@"} -- все аргументы командной строки, заключенные по отдельности в кавычки \cite[\strbook{44}]{robbins:bash-2017}.

После сохранения необходимо сделать этот файл исполняемым при помощи команды\\ \texttt{chmod +x entrypoint.sh}.

Теперь можно создать образ на основе файла \texttt{Dockerfile}
\begin{lstlisting}[
numbers = none
]
docker build -t test/cowsay-dockerfile .
\end{lstlisting}

Здесь \texttt{test} -- имя репозитория, а \texttt{cowsay-dockerfile} -- имя образа.

После этого можно запускать контейнер, который строится на основе образа \verb|test/cowsay-dockerfile|
\begin{lstlisting}[
numbers = none
]
docker run test/cowsay-dockerfile Moo
\end{lstlisting}

\subsection{Пример файла docker-compose.yml}

Рассмотрим в качестве примера файл \texttt{docker-compose.yml} для автоматизации процесса настройки и запуска контейнера
\begin{lstlisting}[
style = bash,
title = {\sffamily docker-compose.yml},
numbers = none
]
registry:
    restart: always
    image: registry:2
    ports:
        - 443:5000
    environment:
        REGISTRY_HTTP_ADDR: 0.0.0.0:5000
        REGISTRY_HTTP_HOST: https://registry.kis.im
        REGISTRY_HTTP_TLS_LETSENCRYPT_CACHEFILE: /tmp/le.cache
        REGISTRY_HTTP_TLS_LETSENCRYPT_EMAIL: ov@rebrain.com
        REGISTRY_HTTP_TLS_LETSENCRYPT_HOSTS: [registry.kis.im]
    volumes:
        - /path/data:/var/lib/registry
        - /path/cers:/certs
\end{lstlisting}

Описание. Создаем сервис \texttt{registry} с политикой постоянной перезагрузки. Образ используется официальный \texttt{registry-2}. Пробрасываем 443 порт на 5000 внутрь контейнера.

Для запуска контейнера достаточно набрать
\begin{lstlisting}[
style = bash,
numbers = none
]
$ docker-compose up -d
\end{lstlisting}

\subsection{Порядок работы с docker-compose}

Обычный порядок работы начинается с выполнения команды для запуска приложения
\begin{lstlisting}[
style = bash,
numbers = none
]
docker-compose up -d
\end{lstlisting}

Команды \texttt{docker-compose logs} и \texttt{docker-compose ps} могут использоваться для проверки состояния приложения и как вспомогательное средство при отладке.

После внесения изменений в исходный код нужно выполнить
\begin{lstlisting}[
style = bash,
numbers = none
]
docker-compose build
\end{lstlisting}
а затем 
\begin{lstlisting}[
style = bash,
numbers = none
]
docker-compose up -d
\end{lstlisting}

При этом будет создан новый образ и заменен работающий контейнер.

\remark{%
Compose сохраняет все ранее существовавшие тома из старых контейнеров, таким образом, базы данных и кэши остаются неизменными при переходе к новым версиям контейнеров (это может привести к беспорядку, поэтому будьте осторожны при замене контейнеров)}

Если создание нового образа не требуется, но внесены изменения в docker-compose.yml, то выполните команду \texttt{docker-compose up -d}, чтобы заменить контейнер на точно такой же, но с новыми настройками.

После завершения сеанса работы с приложением выполните команду \texttt{docker-compose stop} для его остановки. Тот же самый комплект контейнеров будет повторно запущен при выполнении команды \texttt{docker-compose start} или \texttt{docker-compose up -d}, если не был изменен исходный код.

Для окончательного удаления набора контейнеров приложения используйте команду \texttt{docker-compose rm}.



\subsection{Работа с ключами и сертификатами}

Создать ключ и сертификаты можно с помощью утилиты \texttt{openssl}. Создадим корневой ключ
\begin{lstlisting}[
style = bash,
numbers = none
]
$ openssl genrsa -out rootCA.key 2048
\end{lstlisting}

Теперь на основе ключа можно сгенерировать сертификат
\begin{lstlisting}[
style = bash,
numbers = none
]
$ openssl req -x509 -new -key rootCA.key -days 10000 -out rootCA.crt
\end{lstlisting}

Ключ
\begin{lstlisting}[
style = bash,
numbers = none
]
$ cat rootCA.key
# выведет
-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEA1LAK3Os5wgbTFNGzfqbVTbqjv2ExRI0jvS/wHwIWrPuR19K4
4TPegK8dM5DaNbWLCs0Lynp4OuWIUt56MLyH1Ewu9xynycOzRP40otmUGtain8HL
TqPMgA2vvVUA3JbFuN1wsyI9mCdxkSbLH5jwKslkWw9tUPP9k+Mi6NAFF3/RNMPw
5agJqp05M+9AnlgNchqosMxomdQpkXLZuTr7zWrk5vjXksrvszM4nJABGrbrGTnz
ZK51aW7brt023fnxU3HwhmkKthvE8oYhyM23c6G+Ti2zpdI8ILlCMfC/rdKJUmEX
vjuM98zUudxTH6MFVkX8Vq4OUxaVmisXWviGAwIDAQABAoIBAQCkbuY3HnUtGPGg
qu/G/1zyF1X55D6e7S+wWJugnZDCdEyxO21MTzm666f78gWCeLTiyNxQ0paZklPv
HaoCe//Xln7I9hKS3wZ+VLqFHQpwJXjdYoq4ZdL5PZudGVbtNHPxFOLI27QbKoOW
4RMxfqBPtBwueqLdb4WhDH402H7XRsWb9t+bTVtb7agtcjPAvZoV8x5EHlj3LErO
...
-----END RSA PRIVATE KEY-----
\end{lstlisting}

Сертификат
\begin{lstlisting}[
style = bash,
numbers = none
]
$ cat rootCA.crt
# выведет
-----BEGIN CERTIFICATE-----
MIID9zCCAt+gAwIBAgIUB/wdkhR8j3McjC1vNr/0elcPLoMwDQYJKoZIhvcNAQEL
BQAwgYoxCzAJBgNVBAYTAlJVMQ8wDQYDVQQIDAZNb3Njb3cxDzANBgNVBAcMBk1v
c2NvdzEQMA4GA1UECgwHR2F6cHJvbTEQMA4GA1UECwwHT2lsJkdhczELMAkGA1UE
AwwCQ0ExKDAmBgkqhkiG9w0BCQEWGWxlb3IuZmlua2VsYmVyZ0B5YW5kZXgucnUw
HhcNMjAwNjA0MTk1NDAzWhcNNDcxMDIxMTk1NDAzWjCBijELMAkGA1UEBhMCUlUx
DzANBgNVBAgMBk1vc2NvdzEPMA0GA1UEBwwGTW9zY293MRAwDgYDVQQKDAdHYXpw
cm9tMRAwDgYDVQQLDAdPaWwmR2FzMQswCQYDVQQDDAJDQTEoMCYGCSqGSIb3DQEJ
ARYZbGVvci5maW5rZWxiZXJnQHlhbmRleC5ydTCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBANSwCtzrOcIG0xTRs36m1U26o79hMUSNI70v8B8CFqz7kdfS
uOEz3oCvHTOQ2jW1iwrNC8p6eDrliFLeejC8h9RMLvccp8nDs0T+NKLZlBrWop/B
y06jzIANr71VANyWxbjdcLMiPZgncZEmyx+Y8CrJZFsPbVDz/ZPjIujQBRd/0TTD
8OWoCaqdOTPvQJ5YDXIaqLDMaJnUKZFy2bk6+81q5Ob415LK77MzOJyQARq26xk5
82SudWlu267dNt358VNx8IZpCrYbxPKGIcjNt3Ohvk4ts6XSPCC5QjHwv63SiVJh
...
-----END CERTIFICATE-----
\end{lstlisting}

Прочитать сертификат
\begin{lstlisting}[
style = bash,
numbers = none
]
$ openssl x509 -in rootCA.crt -text
# выведет
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            07:fc:1d:92:14:7c:8f:73:1c:8c:2d:6f:36:bf:f4:7a:57:0f:2e:83
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = RU, ST = Moscow, L = Moscow, O = Gazprom, OU = Oil&Gas, CN = CA, emailAddress = leor.finkelberg@yandex.ru
        Validity
            Not Before: Jun  4 19:54:03 2020 GMT
            Not After : Oct 21 19:54:03 2047 GMT
        Subject: C = RU, ST = Moscow, L = Moscow, O = Gazprom, OU = Oil&Gas, CN = CA, emailAddress = leor.finkelberg@yandex.ru
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
            RSA Public-Key: (2048 bit)
            Modulus:
                00:d4:b0:0a:dc:eb:39:c2:06:d3:14:d1:b3:7e:a6:
                d5:4d:ba:a3:bf:61:31:44:8d:23:bd:2f:f0:1f:02:
                16:ac:fb:91:d7:d2:b8:e1:33:de:80:af:1d:33:90:
                da:35:b5:8b:0a:cd:0b:ca:7a:78:3a:e5:88:52:de:
                7a:30:bc:87:d4:4c:2e:f7:1c:a7:c9:c3:b3:44:fe:
...
\end{lstlisting}

Генерируем приватный ключ для \texttt{registry}
\begin{lstlisting}[
style = bash,
numbers = none
]
$ openssl genrsa -out registry.key 2048
\end{lstlisting}

И по ключу создаем запрос сертификата с помощью
\begin{lstlisting}[
style = bash,
numbers = none
]
$ openssl req -new -key registry.key -out registry.csr
\end{lstlisting}

Подписываем корневым сертификатом ключ, который потом надо будет отдать серверу
\begin{lstlisting}[
style = bash,
numbers = none
]
openssl x509 -req -in registry.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out registry.crt -days 5000
# будет создан registry.crt
\end{lstlisting}

Файл \texttt{docker-compose.yml} будет выглядеть так
\begin{lstlisting}[
style = bash,
numbers = none
]
registry:
    restart: always
    image: registry:2
    ports:
        - 443:5000
    environment:
        REGISTRY_HTTP_ADDR: 0.0.0.0:5000
        REGISTRY_HTTP_HOST: https://registry.kis.im
        REGISTRY_HTTP_TLS_CERTIFICATE: /path/to/registry.crt
        REGISTRY_HTTP_TLS_KEY: /path/to/registry.key
    volumes:
        - /path/data:/var/lib/registry
        - /etc/cers:/etc/certs
\end{lstlisting}

Скачаем образ и поместим его в \texttt{registry}
\begin{lstlisting}[
style = bash,
numbers = none
]
$ docker pull alpine:latest
# перетегируем
$ docker tag alpine:latest registry.kis.im/leorfinkelberg/alpine:dev
\end{lstlisting}

Теперь можно отправить перетегированный образ в репозиторий
\begin{lstlisting}[
style = bash,
numbers = none
]
$ docker push registry.kis.im/leorfinkelberg/alpine:dev
\end{lstlisting}

Docker может не доверять самоподписанным сертификатам. Чтобы Docker доверял самоподписанным сертификатам нужно создать в \verb|/etc/| приведенную ниже цепочку каталогов и поместить туда сертификат, т.е.
\begin{lstlisting}[
style = bash,
numbers = none
]
$ cat /etc/docker/certs.d/registry.kis.im/ca.crt
...
\end{lstlisting}

Теперь можно скачивать
\begin{lstlisting}[
style = bash,
numbers = none
]
$ docker pull registry.kis.im/leorfinkelberg/alpine:dev
\end{lstlisting}



\section{Общие сведения о компьютерных сетях}

\subsection{Термины и определения}

\paragraph{{localhost}} (так называемый, <<локальный хост>>, по смыслу <<этот компьютер>>) -- стандартное, официально зарезервированное доменное имя для \emph{частых} (или что то же самое \emph{локальных}) IP-адресов\footnote{Уникальный сетевой адрес узла в компьютерной сети, построенной на базе стека протоколов TCP/IP} \emph{петлевого интерфейса}\footnote{Обычно используется термин \emph{loopback}, который описывает методы или процедуры маршрутизации электронных сигналов, цифровых потоков данных, или других движущихся сущностей от их источника и обратно к тому же источнику без специальной обработки или модификации} (диапазон \texttt{127.0.0.1} -- \texttt{127.255.255.255}). Использование IP-адреса \texttt{127.0.0.1} позволяет устанавливать соединение и передавать информацию для программ-серверов, работающих на том же компьютере, что и программа-клиент. Примером может быть запущенный на компьютере веб-сервер приложений, обращение к которому выполняется с этого же компьютера для веб-разработки на данном компьютере без необходимости выкладывать веб-программу в сеть Интернет, пока ее разработка не закончена. Традиционно IP-адресу \texttt{127.0.0.1} однозначно сопоставляется имя хоста \texttt{localhost}.

\paragraph{{порт}} целое неотрицательное число, записываемое в заголовках \emph{протоколов транспортного уровня} модели OSI (TCP, UDP, SCTP, DCCP). Используется для определения процесса-получателя пакета в пределах одного хоста (локального компьютера).

\section{Базовые концепции, связанные с системой Docker}

\subsection{Структура стека протоколов TCP/IP}

Сегодня стек протоколов TCP/IP используется как в глобальных, так и в локальных сетях. Стек имеет иерархическую, четырхуровневую структуру (см~\tblref{tab:tcpip}).

Прикладной уровень стека TCP/IP соответствует трем верхним уровням модели OSI: прикладному, представления и сеансовому \cite{olifer:compnets-2020}.

\begin{table}[h]
	\centering
	\caption{\itshape Иерархическая структура стека протоколов TCP/IP}\label{tab:tcpip}
	%\renewcommand{\arraystretch}{1.05}
	\begin{tabular}{cl}
		\rowcolor[gray]{0.96} {Прикладной уровень} & FTP, Telnet, HTTP, SMTP, SNMP, TFTP \\
		Транспортный уровень & TCP, UDP \\
		\rowcolor[gray]{0.96} {Сетевой уровень} & IP, ICMP, RIP, OSPF \\
		Уровень сетевых интерфейсов & не регламентируется
	\end{tabular}
\end{table}

Протоколы прикладного уровня развертываются на хостах.

Транспортный уровень стека TCP/IP может предоставлять вышележащему уровню два типа сервиса:

\begin{itemize}
	\item гарантированную доставку обеспечивает \emph{протокол управления передачей} (Transmission Control Protocol, TCP),
	
	\item доставку по возможности, или с максимальными усилиями, обеспечивает \emph{протокол пользовательских дейтаграмм} (User Datagram Protocol, UDP).
\end{itemize}

Чтобы обеспечить надежную доставку данных, протокол TCP предусматривает установление \emph{логического соединения}. Это позволяет нумеровать пакеты, подтверждать их прием квитанциями, организовать в случае потери повторные передачи, распознавать и уничтожать дубликаты, доставлять прикладному уровню пакеты в том порядке, в котором они были отправлены. Благодаря этому протоколу объекты на \emph{хосте-отправителе} и \emph{хосте-получателе} могут поддерживать обмен данными в дуплексном режиме. TCP дает возможность без ошибок доставить сформированный на одном из компьютеров поток байтов на любой другой компьютер, входящий в составную сеть.

Протокол UDP является простейшим \emph{дейтаграммным} протоколом, используемым, если задача надежного обмена данными либо вообще не ставится, либо решается средствами более высокого уровня -- прикладным уровнем или пользовательским приложением.

В функции протоколов TCP и UDP входит также исполнение роли связующего звена между прилегающими к транспортному уровню прикладным и сетевым уровням. От прикладного протокола (например, от HTTP) транспортный уровень принимает задание на передачу данных с тем или иным качеством прикладному уровню-получателю.

Сетей уровень, называемый также уровнем Интернета, является стрежнем всей архитектуры TCP/IP. Протоколы сетевого уровня поддерживают интерфейс с вышележащим транспортным уровнем, получая от него запросы на передачу данных по составной сети, а также с нижележащим уровнем сетевых интерфейсов.

Основным протоколом сетевого уровня является межсетевой протокол (Internet Protocol, IP). В его задачу входит продвижение пакета между сетями -- от одного маршрутизатора к другому до тех пор, пока пакет не попадет в сеть назначения. В отличие от протоколов прикладного уровня и транспортного уровней, протокол IP развертывается не только на хостах, но и на всех маршрутизаторах. Протокол IP -- это дейтаграммный протокол, работающий без установления соединения по принципу доставки с максимальными усилиями. Такой тип сетевого сервиса называют также <<ненадежным>>.

\subsection{Формат IP-адреса}

В заголовке IP-пакета предусмотрены поля для хранения \emph{IP-адреса отправителя} и \emph{IP-адреса получателя}. Каждое из этих полей имеет фиксированную длину 4 байта (32 бита).

IP-адрес состоит из двух логических частей -- номера сети и номера узла в сети. Наиболее распространенная форма представления IP-адреса -- запись в виде четырех чисел, представляющих значения каждого байта в десятичной форме и разделенных точками, например: 128.10.2.30.

Границу в IP-адресе между номером сети и номером узла в сети можно найти с помощью \emph{маски}. Маска -- это число, применяемое в паре с IP-адресом, причем двоичная запись маски содержит непрерывную последовательность единиц в тех разрядах, которые должны в IP-адресе интерпретироваться как номер сети. Граница между последовательностями единиц и нулей в маске соответствует границе между номером сети и номером узла в IP-адресе.

\subsection{Виртуальный сетевой интерфейс}

Все TCP/IP-реализации поддерживают loopback-механизмы, которые реализуют виртуальный сетевой интерфейс исключительно программно и не связанны с каким-либо оборудованием, но при этом полностью интегрированны во внутреннюю сетевую инфраструктуру компьютерной системы. Пожалуй самый распространенным IP-адресом в механизмах loopback является \texttt{127.0.0.1}. В IPv4 в него также отображается любой адрес из диапазона \texttt{127.0.0.0} -- \texttt{127.255.255.255}. IPv6 определяет единственные адрес для этой функции -- \texttt{0:0:0:0:0:0:0:1/128} (так же записывается как \texttt{::1/128}). Стандартное, официально зарезервированное доменное имя для этих адресов -- \texttt{localhost}.

Интерфейс loopback имеет несколько путей применения. Он может быть использован сетевым клиентским программным обеспечением, чтобы общаться с серверным приложением, расположенным на том компьютере. То есть если на компьютере, на котором запущен веб-сервер, указать в веб-браузере URL \texttt{http://127.0.0.1/} или \texttt{http:/localhost/}, то он попадает на веб-сайт этого компьютера.



\section{Пример создания простого web-приложения}

Структура проекта \cite[\strbook{99}]{mouat:docker-2017}
\begin{lstlisting}[
style = cmd,
numbers = none
]
indentidock/
    -- Dockerfile
    -- app/
        -- identidock.py
    -- cmd.sh
    -- docker-compose.yml
\end{lstlisting}

Python-приложение будет выглядеть так
\begin{lstlisting}[
style = ironpython,
title = {\sffamily app/identidock.py},
emph = {mainpage, get_identicon},
numbers = none
]
from flask import Flask, Response, request
import requests
import hashlib
import redis

app = Flask(__name__)
cache = redis.StrictRedis(host='redis', port=6379, db=0)
salt = 'UNIQUE_SALT'
default_name = 'Leor Finkelberg'

@app.route('/', methods=['GET', 'POST'])
def mainpage():
    name = default_name
    if request.method == 'POST':
        name = request.form['name']

        salted_name = salt + name
        name_hash = hashlib.sha256(salted_name.encode()).hexdigest()
        header = '<html><head><title>Identidock</title></head><body>'
        body = '''<form method='POST'>
                      Hell <input type='text' name='name' value='{0}'>
                      <input type='submit' value='submit'>
                  </form>
                  <p>You look like a:
                  <img src='/monster/{1}'/>
               '''.format(name, name_hash)
    footer = '</body></html>'

    return header + body + footer


@app.route('/monster/<name>')
def get_identicon(name):
    image = cache.get(name)
    if image is None:
        print('Cache miss', flush=True)
        r = requests.get('http://dnmonster:8080/monster/' + name + '?size=80')
        image = r.content
        cache.set(name, image)

    return Response(image, mimetype='image/png')


if __name__ == '__main__':
    app.run(debug = True, port = 5000)
\end{lstlisting}

bash-сценарий управляет режимами запуска приложения
\begin{lstlisting}[
style = bash,
title = {\sffamily ./cmd.sh},
numbers = none
]
#!/bin/bash
set-e

if [[ "$ENV" == 'DEV' ]]; then
    echo 'Running Development Server'
    exec python 'identidock.py'
else
    echo 'Running Production Server'
    ...
fi
\end{lstlisting}

\begin{lstlisting}[
style = bash,
title = {\sffamily ./Dockerfile},
numbers = none
]
FROM python:3.5

RUN groupadd -r uwsgi && useradd -r -g uwsgi uwsgi
RUN pip install Flask==1.1.1 gunicorn==20.0.0 requests==2.22.0 redis==3.5.0
WORKDIR /app
COPY app /app
COPY cmd.sh /

EXPOSE 9090 9191
USER uwsgi

CMD ["/cmd.sh"]
\end{lstlisting}

\begin{lstlisting}[
style = bash,
title = {\sffamily ./docker-compose.yml},
numbers = none
]
identidock:
    build: .
    ports: 
        - "5000:5000"
    environment:
        ENV: DEV
    volumes:
        - "./app:/app"
    links:
        - dnmonster
        - redis

dnmonster:
    image: amouat/dnmonster:1.0

redis:
    image: redis:alpine3.12
\end{lstlisting}


\section{Наиболее полезные конструкции}

\subsection{Манипуляции с контейнерами}

Запустить контейнер с именем \texttt{leorcont}, создав сеанс интерактивной работы (\texttt{-i}) на подключаемом терминальном устройстве (\texttt{-t}) tty, и вызывать командную оболочку \texttt{bash} из-под ОС~\texttt{Ubuntu Linux}

\begin{lstlisting}[
numbers = none
]
docker run -it --name leorcont ubuntu bash
\end{lstlisting}

Запустить контейнер, а после остановки удалить сам контейнер и созданную на время его существования файловую систему

\begin{lstlisting}[
numbers = none
]
docker run --rm -it ubuntu bash
\end{lstlisting}

Перезапустить остановленный контейнер

\begin{lstlisting}[
numbers = none
]
docker start quizzical_wright
\end{lstlisting}

\subsection{Информация о контейнере}

Получить информацию о контейнере

\begin{lstlisting}[
numbers = none
]
docker inspect quizzical_wright
\end{lstlisting}

Вывести информацию о контейнере с использованием утилиты \texttt{grep}

\begin{lstlisting}[
numbers = none
]
docker inspect quizzical_wright | grep SandboxID
\end{lstlisting}

Вывести информацию о контейнере с использованием шаблона языка \texttt{Go} \url{https://metanit.com/go/web/2.2.php}

\begin{lstlisting}[
numbers = none
]
docker inspect --format {{.NetworkSettings.SandboxID}} quizzical_wright
\end{lstlisting}

Вывести список файлов в работающем контейнере. Для контейнеров \texttt{Docker} использует файловую систему \texttt{UnionFS}, которая позволяет монтировать несколько файловых систем в общую иерархию, которая выглядит как \emph{единая файловая система}. Файловая система конкретного \emph{образа} смонтирована как уровень \emph{только для чтения}, а любые изменения в работающем контейнере происходят на уровне с разрешенной записью, монтируемого поверх основной {файловой системы образа}. Поэтому \texttt{Docker} при поиске изменений в работающей системе должен рассматривать только самый верхний уровень, на котором возможна запись \cite{mouat:docker-2017}

\begin{lstlisting}[
numbers = none
]
docker diff quizzical_wright
\end{lstlisting}

Вывести список работающих контейнеров

\begin{lstlisting}[
numbers = none
]
docker ps
\end{lstlisting}

Вывести список всех контейнеров, включая остановленные (stopped)\footnote{Формально их называют контейнерами, из которых был совершен выход (exited containers)}. Такие контейнеры могут быть перезапущены с помощью \texttt{docker start}

\begin{lstlisting}[
numbers = none
]
docker ps -a
\end{lstlisting}

\subsection{Удаление контейнеров и образов}

Удалить контейнер 

\begin{lstlisting}[
numbers = none
]
docker rm quizzical_wright
\end{lstlisting}

Удалить несколько остановленных контейнеров можно следующим способом. Значение флагов: \texttt{-a} (все контейнеры), \texttt{-q} (вывести только числовой идентификатор контейнера), \texttt{-f} (фильтр), \texttt{-v} (все тома, на которые не ссылаются какие-либо другие контейнеры)

\begin{lstlisting}[
numbers = none
]
docker rm -v $(docker ps -aq -f status=exited)
\end{lstlisting}

Удалить все образы 
\begin{lstlisting}[
style = bash,
numbers = none
]
docker rmi $(docker images | sed '1d' | awk -F ' ' '{ print $3 }')
\end{lstlisting}


% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{mouat:docker-2017}{ \emph{Моуэт Э.} Использование Docker. -- М.: ДМК Пресс, 2017. -- 354 с. }
	
	\bibitem{robbins:bash-2017}{ \emph{Роббинс А.} Bash. Карманный справочник системного администратора, 2-е изд.: Пер. с англ. -- СПб.: ООО <<Альфа-книга>>, 2017. -- 152 с.}
	
	\bibitem{olifer:compnets-2020}{\emph{Олифер В.}, \emph{Олифер Н.} Компьютерные сети. Принципы, технологии, протоколы. -- СПб.: Питер, 2020. -- 1008 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}


\end{document}
